### THIS FILE IS AUTOGENERATED. DO NOT EDIT THIS FILE DIRECTLY ###
from .production_pb2_grpc import *
from . import production_pb2
from minLights.rpc.production_pb2 import *
from minLights.rpc._support import MessageWrapper, ArgumentError
import time
import logging

__all__ = [
    "ProductionService",
    "WriteFlowcellDataRequest",
    "WriteFlowcellDataResponse",
    "WriteFlowcellIdRequest",
    "WriteFlowcellIdResponse",
    "WriteWellsPerChannelRequest",
    "WriteWellsPerChannelResponse",
    "WriteProductCodeRequest",
    "WriteProductCodeResponse",
    "WriteTemperatureOffsetRequest",
    "WriteTemperatureOffsetResponse",
]

class ProductionService(object):
    def __init__(self, channel):
        self._stub = ProductionServiceStub(channel)
        self._pb = production_pb2

    def write_flowcell_data(self, _message=None, _timeout=None, **kwargs):
        """
        Writes data to the EEPROM on the attached flowcell.

        This call will fail with FAILED_PRECONDITION if there is no device connected or no flowcell
        attached.

        Very little checking of the provided values is done, and no attempt is made to preserve
        existing data. Use the other methods on this service for that.

        :param empty:
            Clears any existing data from the EEPROM.
        :param v1:
            Writes version 1 data to the EEPROM.
        :param v2:
            Writes version 2 data to the EEPROM.
        :param v3:
            Writes version 3 data to the EEPROM.
        :param v4:
            Writes version 4 data to the EEPROM.
        :param v5:
            Writes version 5 data to the EEPROM.
        :param v6:
            Writes version 6 data to the EEPROM.
        :rtype: WriteFlowcellDataResponse
        """
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            retry_count = 20
            error = None
            for i in range(retry_count):
                try:
                    result = MessageWrapper(self._stub.write_flowcell_data(_message, timeout=_timeout), unwraps=[])
                    return result
                except grpc.RpcError as e:
                    # Retrying unidentified grpc errors to keep clients from crashing
                    if (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details()) or\
                    (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()):
                        logging.info('Bypassed ({}: {}) error for grpc: ont.rpc.production.ProductionService.write_flowcell_data. Attempt {}.'.format(e.code(), e.details(), i))
                    else:
                        raise
                    error = e
                time.sleep(1)
            raise error

        unused_args = set(kwargs.keys())

        # check oneof group 'data'
        oneof_fields = set([
            'empty',
            'v1',
            'v2',
            'v3',
            'v4',
            'v5',
            'v6',
        ])
        if len(unused_args & oneof_fields) > 1:
            raise ArgumentError("write_flowcell_data given multiple conflicting arguments: '{}'".format("', '".join(unused_args & oneof_fields)))
        _message = WriteFlowcellDataRequest()

        if 'empty' in kwargs:
            unused_args.remove('empty')
            _message.empty.CopyFrom(kwargs['empty'])

        if 'v1' in kwargs:
            unused_args.remove('v1')
            _message.v1.CopyFrom(kwargs['v1'])

        if 'v2' in kwargs:
            unused_args.remove('v2')
            _message.v2.CopyFrom(kwargs['v2'])

        if 'v3' in kwargs:
            unused_args.remove('v3')
            _message.v3.CopyFrom(kwargs['v3'])

        if 'v4' in kwargs:
            unused_args.remove('v4')
            _message.v4.CopyFrom(kwargs['v4'])

        if 'v5' in kwargs:
            unused_args.remove('v5')
            _message.v5.CopyFrom(kwargs['v5'])

        if 'v6' in kwargs:
            unused_args.remove('v6')
            _message.v6.CopyFrom(kwargs['v6'])

        if len(unused_args) > 0:
            raise ArgumentError("write_flowcell_data got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        retry_count = 20
        error = None
        for i in range(retry_count):
            try:
                result = MessageWrapper(self._stub.write_flowcell_data(_message, timeout=_timeout), unwraps=[])
                return result
            except grpc.RpcError as e:
                # Retrying unidentified grpc errors to keep clients from crashing
                if (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details()) or\
                (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()):
                    logging.info('Bypassed ({}: {}) error for grpc: ont.rpc.production.ProductionService.write_flowcell_data. Attempt {}.'.format(e.code(), e.details(), i))
                else:
                    raise
                error = e
            time.sleep(1)
        raise error

    def write_flowcell_id(self, _message=None, _timeout=None, **kwargs):
        """
        Write the flowcell ID to the flowcell EEPROM.

        Flowcell IDs over 8 characters or containing unprintable characters will be rejected with
        INVALID_ARGUMENT. An empty string effectively clears the flowcell ID.

        If nothing is currently written on the flowcell EEPROM, it will write the data in a suitable
        format. If the EEPROM contains a data version that supports this field, it will be updated,
        and all other fields will be preserved. If the EEPROM contains a data version that doesn't
        support this field, this call will fail with FAILED_PRECONDITION and the EEPROM will not be
        changed.

        This call will fail with FAILED_PRECONDITION if there is no device connected or no flowcell
        attached, or if the flowcell's EEPROM is corrupt or has data in an unknown version.

        :param flowcell_id:
        :rtype: WriteFlowcellIdResponse
        """
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            retry_count = 20
            error = None
            for i in range(retry_count):
                try:
                    result = MessageWrapper(self._stub.write_flowcell_id(_message, timeout=_timeout), unwraps=[])
                    return result
                except grpc.RpcError as e:
                    # Retrying unidentified grpc errors to keep clients from crashing
                    if (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details()) or\
                    (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()):
                        logging.info('Bypassed ({}: {}) error for grpc: ont.rpc.production.ProductionService.write_flowcell_id. Attempt {}.'.format(e.code(), e.details(), i))
                    else:
                        raise
                    error = e
                time.sleep(1)
            raise error

        unused_args = set(kwargs.keys())

        _message = WriteFlowcellIdRequest()

        if 'flowcell_id' in kwargs:
            unused_args.remove('flowcell_id')
            _message.flowcell_id = kwargs['flowcell_id']

        if len(unused_args) > 0:
            raise ArgumentError("write_flowcell_id got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        retry_count = 20
        error = None
        for i in range(retry_count):
            try:
                result = MessageWrapper(self._stub.write_flowcell_id(_message, timeout=_timeout), unwraps=[])
                return result
            except grpc.RpcError as e:
                # Retrying unidentified grpc errors to keep clients from crashing
                if (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details()) or\
                (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()):
                    logging.info('Bypassed ({}: {}) error for grpc: ont.rpc.production.ProductionService.write_flowcell_id. Attempt {}.'.format(e.code(), e.details(), i))
                else:
                    raise
                error = e
            time.sleep(1)
        raise error

    def write_wells_per_channel(self, _message=None, _timeout=None, **kwargs):
        """
        Write the number of wells to the flowcell EEPROM.

        Well counts greater than the number supported by the hardware will be rejected. Passing zero
        will effectively set it to the default for this device.

        If nothing is currently written on the flowcell EEPROM, it will write the data in a suitable
        format. If the EEPROM contains a data version that supports this field, it will be updated,
        and all other fields will be preserved. If the EEPROM contains a data version that doesn't
        support this field, this call will fail with FAILED_PRECONDITION and the EEPROM will not be
        changed.

        This call will fail with FAILED_PRECONDITION if there is no device connected or no flowcell
        attached, or if the flowcell's EEPROM is corrupt or has data in an unknown version.

        :param wells_per_channel:
        :rtype: WriteWellsPerChannelResponse
        """
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            retry_count = 20
            error = None
            for i in range(retry_count):
                try:
                    result = MessageWrapper(self._stub.write_wells_per_channel(_message, timeout=_timeout), unwraps=[])
                    return result
                except grpc.RpcError as e:
                    # Retrying unidentified grpc errors to keep clients from crashing
                    if (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details()) or\
                    (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()):
                        logging.info('Bypassed ({}: {}) error for grpc: ont.rpc.production.ProductionService.write_wells_per_channel. Attempt {}.'.format(e.code(), e.details(), i))
                    else:
                        raise
                    error = e
                time.sleep(1)
            raise error

        unused_args = set(kwargs.keys())

        _message = WriteWellsPerChannelRequest()

        if 'wells_per_channel' in kwargs:
            unused_args.remove('wells_per_channel')
            _message.wells_per_channel = kwargs['wells_per_channel']

        if len(unused_args) > 0:
            raise ArgumentError("write_wells_per_channel got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        retry_count = 20
        error = None
        for i in range(retry_count):
            try:
                result = MessageWrapper(self._stub.write_wells_per_channel(_message, timeout=_timeout), unwraps=[])
                return result
            except grpc.RpcError as e:
                # Retrying unidentified grpc errors to keep clients from crashing
                if (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details()) or\
                (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()):
                    logging.info('Bypassed ({}: {}) error for grpc: ont.rpc.production.ProductionService.write_wells_per_channel. Attempt {}.'.format(e.code(), e.details(), i))
                else:
                    raise
                error = e
            time.sleep(1)
        raise error

    def write_product_code(self, _message=None, _timeout=None, **kwargs):
        """
        Write the product code to the flowcell EEPROM.

        This is the code presented to customers in the shop, eg: "FLO-MIN106".

        Produce codes over 10 characters or containing unprintable characters will be rejected with
        INVALID_ARGUMENT. An empty string effectively clears the product code.

        If nothing is currently written on the flowcell EEPROM, it will write the data in a suitable
        format. If the EEPROM contains a data version that supports this field, it will be updated,
        and all other fields will be preserved. If the EEPROM contains a data version that doesn't
        support this field, this call will fail with FAILED_PRECONDITION and the EEPROM will not be
        changed.

        This call will fail with FAILED_PRECONDITION if there is no device connected or no flowcell
        attached, or if the flowcell's EEPROM is corrupt or has data in an unknown version.

        :param product_code:
        :rtype: WriteProductCodeResponse
        """
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            retry_count = 20
            error = None
            for i in range(retry_count):
                try:
                    result = MessageWrapper(self._stub.write_product_code(_message, timeout=_timeout), unwraps=[])
                    return result
                except grpc.RpcError as e:
                    # Retrying unidentified grpc errors to keep clients from crashing
                    if (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details()) or\
                    (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()):
                        logging.info('Bypassed ({}: {}) error for grpc: ont.rpc.production.ProductionService.write_product_code. Attempt {}.'.format(e.code(), e.details(), i))
                    else:
                        raise
                    error = e
                time.sleep(1)
            raise error

        unused_args = set(kwargs.keys())

        _message = WriteProductCodeRequest()

        if 'product_code' in kwargs:
            unused_args.remove('product_code')
            _message.product_code = kwargs['product_code']

        if len(unused_args) > 0:
            raise ArgumentError("write_product_code got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        retry_count = 20
        error = None
        for i in range(retry_count):
            try:
                result = MessageWrapper(self._stub.write_product_code(_message, timeout=_timeout), unwraps=[])
                return result
            except grpc.RpcError as e:
                # Retrying unidentified grpc errors to keep clients from crashing
                if (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details()) or\
                (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()):
                    logging.info('Bypassed ({}: {}) error for grpc: ont.rpc.production.ProductionService.write_product_code. Attempt {}.'.format(e.code(), e.details(), i))
                else:
                    raise
                error = e
            time.sleep(1)
        raise error

    def write_temperature_offset(self, _message=None, _timeout=None, **kwargs):
        """
        Write the temperature offset to the flowcell EEPROM.

        The temperature offset is specified in hundreths of a degree Celsius, and can range from
        -327.67 degrees Celsius to 327.67 degrees Celsius. The value -32767 will be accepted, but
        will cause the temperature offset to cleared, just as though no value had been provided at
        all.

        If nothing is currently written on the flowcell EEPROM, it will write the data in a suitable
        format. If the EEPROM contains a data version that supports this field, it will be updated,
        and all other fields will be preserved. If the EEPROM contains a data version that doesn't
        support this field, this call will fail with FAILED_PRECONDITION and the EEPROM will not be
        changed.

        This call will fail with FAILED_PRECONDITION if there is no device connected or no flowcell
        attached, or if the flowcell's EEPROM is corrupt or has data in an unknown version.

        :param offset:
        :rtype: WriteTemperatureOffsetResponse
        """
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            retry_count = 20
            error = None
            for i in range(retry_count):
                try:
                    result = MessageWrapper(self._stub.write_temperature_offset(_message, timeout=_timeout), unwraps=[])
                    return result
                except grpc.RpcError as e:
                    # Retrying unidentified grpc errors to keep clients from crashing
                    if (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details()) or\
                    (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()):
                        logging.info('Bypassed ({}: {}) error for grpc: ont.rpc.production.ProductionService.write_temperature_offset. Attempt {}.'.format(e.code(), e.details(), i))
                    else:
                        raise
                    error = e
                time.sleep(1)
            raise error

        unused_args = set(kwargs.keys())

        _message = WriteTemperatureOffsetRequest()

        if 'offset' in kwargs:
            unused_args.remove('offset')
            _message.offset = kwargs['offset']

        if len(unused_args) > 0:
            raise ArgumentError("write_temperature_offset got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        retry_count = 20
        error = None
        for i in range(retry_count):
            try:
                result = MessageWrapper(self._stub.write_temperature_offset(_message, timeout=_timeout), unwraps=[])
                return result
            except grpc.RpcError as e:
                # Retrying unidentified grpc errors to keep clients from crashing
                if (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details()) or\
                (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()):
                    logging.info('Bypassed ({}: {}) error for grpc: ont.rpc.production.ProductionService.write_temperature_offset. Attempt {}.'.format(e.code(), e.details(), i))
                else:
                    raise
                error = e
            time.sleep(1)
        raise error


