### THIS FILE IS AUTOGENERATED. DO NOT EDIT THIS FILE DIRECTLY ###
from .protocol_pb2_grpc import *
from . import protocol_pb2
from minLights.rpc.protocol_pb2 import *
from minLights.rpc._support import MessageWrapper, ArgumentError
import time
import logging

__all__ = [
    "ProtocolService",
    "ProtocolRunUserInfo",
    "StartProtocolRequest",
    "StartProtocolResponse",
    "StopProtocolRequest",
    "StopProtocolResponse",
    "ListProtocolsRequest",
    "ProtocolInfo",
    "ListProtocolsResponse",
    "WaitForFinishedRequest",
    "GetRunInfoRequest",
    "Epi2meWorkflowReference",
    "ProtocolRunInfo",
    "ListProtocolRunsRequest",
    "ListProtocolRunsResponse",
    "GetCurrentProtocolRunRequest",
    "GetCurrentProtocolRunResponse",
    "WatchCurrentProtocolRunRequest",
    "GetContextInfoRequest",
    "GetContextInfoResponse",
    "SetContextInfoRequest",
    "SetContextInfoResponse",
    "GetSampleIdRequest",
    "GetSampleIdResponse",
    "SetSampleIdRequest",
    "SetSampleIdResponse",
    "GetProtocolPurposeRequest",
    "GetProtocolPurposeResponse",
    "SetProtocolPurposeRequest",
    "SetProtocolPurposeResponse",
    "AddEpi2meWorkflowRequest",
    "AddEpi2meWorkflowResponse",
    "ListProtocolGroupIdsRequest",
    "ListProtocolGroupIdsResponse",
    "ProtocolState",
    "PROTOCOL_RUNNING",
    "PROTOCOL_WAITING_FOR_TEMPERATURE",
    "PROTOCOL_WAITING_FOR_ACQUISITION",
    "PROTOCOL_COMPLETED",
    "PROTOCOL_STOPPED_BY_USER",
    "PROTOCOL_FINISHED_WITH_ERROR",
    "PROTOCOL_FINISHED_WITH_DEVICE_ERROR",
    "PROTOCOL_FINISHED_UNABLE_TO_SEND_TELEMETRY",
]

class ProtocolService(object):
    def __init__(self, channel):
        self._stub = ProtocolServiceStub(channel)
        self._pb = protocol_pb2

    def start_protocol(self, _message=None, _timeout=None, **kwargs):
        """
        Initiates a python instance that runs the script specified by the `path` argument.
        `list_protocols` will give back a list of protocol scripts that can be started by this call

        :param identifier: (required)
            The identifier of the protocol, as provided by list_protocols().
        :param args:
            The arguments to pass to the protocol.
        :param user_info:
            User input describing the protocol.
        :rtype: StartProtocolResponse
        """
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            retry_count = 20
            error = None
            for i in range(retry_count):
                try:
                    result = MessageWrapper(self._stub.start_protocol(_message, timeout=_timeout), unwraps=[])
                    return result
                except grpc.RpcError as e:
                    # Retrying unidentified grpc errors to keep clients from crashing
                    if (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details()) or\
                    (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()):
                        logging.info('Bypassed ({}: {}) error for grpc: ont.rpc.protocol.ProtocolService.start_protocol. Attempt {}.'.format(e.code(), e.details(), i))
                    else:
                        raise
                    error = e
                time.sleep(1)
            raise error

        unused_args = set(kwargs.keys())

        _message = StartProtocolRequest()

        if 'identifier' in kwargs:
            unused_args.remove('identifier')
            _message.identifier = kwargs['identifier']
        else:
            raise ArgumentError("start_protocol requires a 'identifier' argument")

        if 'args' in kwargs:
            unused_args.remove('args')
            _message.args.extend(kwargs['args'])

        if 'user_info' in kwargs:
            unused_args.remove('user_info')
            _message.user_info.CopyFrom(kwargs['user_info'])

        if len(unused_args) > 0:
            raise ArgumentError("start_protocol got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        retry_count = 20
        error = None
        for i in range(retry_count):
            try:
                result = MessageWrapper(self._stub.start_protocol(_message, timeout=_timeout), unwraps=[])
                return result
            except grpc.RpcError as e:
                # Retrying unidentified grpc errors to keep clients from crashing
                if (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details()) or\
                (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()):
                    logging.info('Bypassed ({}: {}) error for grpc: ont.rpc.protocol.ProtocolService.start_protocol. Attempt {}.'.format(e.code(), e.details(), i))
                else:
                    raise
                error = e
            time.sleep(1)
        raise error

    def stop_protocol(self, _message=None, _timeout=None, **kwargs):
        """
        Stops the currently running protocol script instance.

        :param data_action_on_stop:
            Specify how any running acquisition should
            be handled when stopping the protocol.

            Protocol state will enter PROTOCOL_WAITING_FOR_ACQUISITION whilst any running
            acquisition is finished.

            If a script ends on its own any analysis that was started is stopped, and it
            is allowed to catchup. If the caller wants to end catchup they can call stop_protocol
            to end catchup.

            Since 1.15
        :rtype: StopProtocolResponse
        """
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            retry_count = 20
            error = None
            for i in range(retry_count):
                try:
                    result = MessageWrapper(self._stub.stop_protocol(_message, timeout=_timeout), unwraps=[])
                    return result
                except grpc.RpcError as e:
                    # Retrying unidentified grpc errors to keep clients from crashing
                    if (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details()) or\
                    (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()):
                        logging.info('Bypassed ({}: {}) error for grpc: ont.rpc.protocol.ProtocolService.stop_protocol. Attempt {}.'.format(e.code(), e.details(), i))
                    else:
                        raise
                    error = e
                time.sleep(1)
            raise error

        unused_args = set(kwargs.keys())

        _message = StopProtocolRequest()

        if 'data_action_on_stop' in kwargs:
            unused_args.remove('data_action_on_stop')
            _message.data_action_on_stop = kwargs['data_action_on_stop']

        if len(unused_args) > 0:
            raise ArgumentError("stop_protocol got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        retry_count = 20
        error = None
        for i in range(retry_count):
            try:
                result = MessageWrapper(self._stub.stop_protocol(_message, timeout=_timeout), unwraps=[])
                return result
            except grpc.RpcError as e:
                # Retrying unidentified grpc errors to keep clients from crashing
                if (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details()) or\
                (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()):
                    logging.info('Bypassed ({}: {}) error for grpc: ont.rpc.protocol.ProtocolService.stop_protocol. Attempt {}.'.format(e.code(), e.details(), i))
                else:
                    raise
                error = e
            time.sleep(1)
        raise error

    def wait_for_finished(self, _message=None, _timeout=None, **kwargs):
        """
        Wait for a protocol run to finish.

        The call blocks until the run with the given run ID has finished (or returns immediately if
        it had already finished) and returns information about the protocol run.

        If no run has been started with the provided run ID (or no run ID is given), an error is
        returned.

        If NOTIFY_BEFORE_TERMINATION is specified for state, the protocol end time is an estimate, including
        the allowed timeout.

        Since 1.10

        :param run_id: (required)
            Only consider a specific protocol run.
        :param state:
            Control what to wait for.

            Specifying NOTIFY_BEFORE_TERMINATION allows a caller to be notified the script will be ended _soon_,
            and do final work to end cleanly.

            Since 1.11
        :param timeout:
            Timeout to wait for finished, if the timeout expires before the protocol is complete (in the state requested)
            then the response returns.

            By default the timeout will wait forever.

            Since 1.15
        :rtype: ProtocolRunInfo
        """
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            retry_count = 20
            error = None
            for i in range(retry_count):
                try:
                    result = MessageWrapper(self._stub.wait_for_finished(_message, timeout=_timeout), unwraps=[])
                    return result
                except grpc.RpcError as e:
                    # Retrying unidentified grpc errors to keep clients from crashing
                    if (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details()) or\
                    (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()):
                        logging.info('Bypassed ({}: {}) error for grpc: ont.rpc.protocol.ProtocolService.wait_for_finished. Attempt {}.'.format(e.code(), e.details(), i))
                    else:
                        raise
                    error = e
                time.sleep(1)
            raise error

        unused_args = set(kwargs.keys())

        _message = WaitForFinishedRequest()

        if 'run_id' in kwargs:
            unused_args.remove('run_id')
            _message.run_id = kwargs['run_id']
        else:
            raise ArgumentError("wait_for_finished requires a 'run_id' argument")

        if 'state' in kwargs:
            unused_args.remove('state')
            _message.state = kwargs['state']

        if 'timeout' in kwargs:
            unused_args.remove('timeout')
            _message.timeout = kwargs['timeout']

        if len(unused_args) > 0:
            raise ArgumentError("wait_for_finished got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        retry_count = 20
        error = None
        for i in range(retry_count):
            try:
                result = MessageWrapper(self._stub.wait_for_finished(_message, timeout=_timeout), unwraps=[])
                return result
            except grpc.RpcError as e:
                # Retrying unidentified grpc errors to keep clients from crashing
                if (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details()) or\
                (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()):
                    logging.info('Bypassed ({}: {}) error for grpc: ont.rpc.protocol.ProtocolService.wait_for_finished. Attempt {}.'.format(e.code(), e.details(), i))
                else:
                    raise
                error = e
            time.sleep(1)
        raise error

    def get_run_info(self, _message=None, _timeout=None, **kwargs):
        """
        Gets information about a protocol run.

        If no run ID is provided, information about the most recently started protocol run is
        provided.

        Since 1.10

        :param run_id:
            The protocol run to get information about.
        :rtype: ProtocolRunInfo
        """
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            retry_count = 20
            error = None
            for i in range(retry_count):
                try:
                    result = MessageWrapper(self._stub.get_run_info(_message, timeout=_timeout), unwraps=[])
                    return result
                except grpc.RpcError as e:
                    # Retrying unidentified grpc errors to keep clients from crashing
                    if (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details()) or\
                    (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()):
                        logging.info('Bypassed ({}: {}) error for grpc: ont.rpc.protocol.ProtocolService.get_run_info. Attempt {}.'.format(e.code(), e.details(), i))
                    else:
                        raise
                    error = e
                time.sleep(1)
            raise error

        unused_args = set(kwargs.keys())

        _message = GetRunInfoRequest()

        if 'run_id' in kwargs:
            unused_args.remove('run_id')
            _message.run_id = kwargs['run_id']

        if len(unused_args) > 0:
            raise ArgumentError("get_run_info got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        retry_count = 20
        error = None
        for i in range(retry_count):
            try:
                result = MessageWrapper(self._stub.get_run_info(_message, timeout=_timeout), unwraps=[])
                return result
            except grpc.RpcError as e:
                # Retrying unidentified grpc errors to keep clients from crashing
                if (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details()) or\
                (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()):
                    logging.info('Bypassed ({}: {}) error for grpc: ont.rpc.protocol.ProtocolService.get_run_info. Attempt {}.'.format(e.code(), e.details(), i))
                else:
                    raise
                error = e
            time.sleep(1)
        raise error

    def list_protocol_runs(self, _message=None, _timeout=None, **kwargs):
        """
        List previously started protocol run ids (including any current protocol), in order of starting.

        The returned object can be used to find protocol information with get_run_info.

        Since 1.11

        :rtype: ListProtocolRunsResponse
        """
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            retry_count = 20
            error = None
            for i in range(retry_count):
                try:
                    result = MessageWrapper(self._stub.list_protocol_runs(_message, timeout=_timeout), unwraps=[])
                    return result
                except grpc.RpcError as e:
                    # Retrying unidentified grpc errors to keep clients from crashing
                    if (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details()) or\
                    (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()):
                        logging.info('Bypassed ({}: {}) error for grpc: ont.rpc.protocol.ProtocolService.list_protocol_runs. Attempt {}.'.format(e.code(), e.details(), i))
                    else:
                        raise
                    error = e
                time.sleep(1)
            raise error

        unused_args = set(kwargs.keys())

        _message = ListProtocolRunsRequest()

        if len(unused_args) > 0:
            raise ArgumentError("list_protocol_runs got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        retry_count = 20
        error = None
        for i in range(retry_count):
            try:
                result = MessageWrapper(self._stub.list_protocol_runs(_message, timeout=_timeout), unwraps=[])
                return result
            except grpc.RpcError as e:
                # Retrying unidentified grpc errors to keep clients from crashing
                if (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details()) or\
                (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()):
                    logging.info('Bypassed ({}: {}) error for grpc: ont.rpc.protocol.ProtocolService.list_protocol_runs. Attempt {}.'.format(e.code(), e.details(), i))
                else:
                    raise
                error = e
            time.sleep(1)
        raise error

    def get_current_protocol_run(self, _message=None, _timeout=None, **kwargs):
        """
        Returns the name and run id of the currently running protocol.

        Will fail with FAILED_PRECONDITION if there is no protocol running

        Since 1.11

        :rtype: ProtocolRunInfo
        """
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            retry_count = 20
            error = None
            for i in range(retry_count):
                try:
                    result = MessageWrapper(self._stub.get_current_protocol_run(_message, timeout=_timeout), unwraps=[])
                    return result
                except grpc.RpcError as e:
                    # Retrying unidentified grpc errors to keep clients from crashing
                    if (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details()) or\
                    (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()):
                        logging.info('Bypassed ({}: {}) error for grpc: ont.rpc.protocol.ProtocolService.get_current_protocol_run. Attempt {}.'.format(e.code(), e.details(), i))
                    else:
                        raise
                    error = e
                time.sleep(1)
            raise error

        unused_args = set(kwargs.keys())

        _message = GetCurrentProtocolRunRequest()

        if len(unused_args) > 0:
            raise ArgumentError("get_current_protocol_run got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        retry_count = 20
        error = None
        for i in range(retry_count):
            try:
                result = MessageWrapper(self._stub.get_current_protocol_run(_message, timeout=_timeout), unwraps=[])
                return result
            except grpc.RpcError as e:
                # Retrying unidentified grpc errors to keep clients from crashing
                if (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details()) or\
                (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()):
                    logging.info('Bypassed ({}: {}) error for grpc: ont.rpc.protocol.ProtocolService.get_current_protocol_run. Attempt {}.'.format(e.code(), e.details(), i))
                else:
                    raise
                error = e
            time.sleep(1)
        raise error

    def watch_current_protocol_run(self, _message=None, _timeout=None, **kwargs):
        """
        Returns current protocol run info and streams any changes to the current protocol

        This call can be made even if there is no current protocol running. In this case, the next streamed
        response will be the start of a new protocol instance and you will receive updates for that protocol
        until it finishes

        If a protocol finishes this stream will still continue to run and you will be notified when a new protocol starts

        Since 1.12

        :rtype: ProtocolRunInfo
        """
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            retry_count = 20
            error = None
            for i in range(retry_count):
                try:
                    result = MessageWrapper(self._stub.watch_current_protocol_run(_message, timeout=_timeout), unwraps=[])
                    return result
                except grpc.RpcError as e:
                    # Retrying unidentified grpc errors to keep clients from crashing
                    if (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details()) or\
                    (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()):
                        logging.info('Bypassed ({}: {}) error for grpc: ont.rpc.protocol.ProtocolService.watch_current_protocol_run. Attempt {}.'.format(e.code(), e.details(), i))
                    else:
                        raise
                    error = e
                time.sleep(1)
            raise error

        unused_args = set(kwargs.keys())

        _message = WatchCurrentProtocolRunRequest()

        if len(unused_args) > 0:
            raise ArgumentError("watch_current_protocol_run got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        retry_count = 20
        error = None
        for i in range(retry_count):
            try:
                result = MessageWrapper(self._stub.watch_current_protocol_run(_message, timeout=_timeout), unwraps=[])
                return result
            except grpc.RpcError as e:
                # Retrying unidentified grpc errors to keep clients from crashing
                if (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details()) or\
                (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()):
                    logging.info('Bypassed ({}: {}) error for grpc: ont.rpc.protocol.ProtocolService.watch_current_protocol_run. Attempt {}.'.format(e.code(), e.details(), i))
                else:
                    raise
                error = e
            time.sleep(1)
        raise error

    def list_protocols(self, _message=None, _timeout=None, **kwargs):
        """
        Gives back a list that contains info about each possible protocol script minknow is aware of.
        This will most likely be used to retrieve a suitable protocol script that can be passed on to `start_protocol`

        Since 1.10

        :param force_reload:
            If this is false, then will try to use the cached value of the protocol list where possible
            (still subject to changes in flow cell).
            If this is true, then will force a reload of the protocol list

            Defaults to false
        :rtype: ListProtocolsResponse
        """
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            retry_count = 20
            error = None
            for i in range(retry_count):
                try:
                    result = MessageWrapper(self._stub.list_protocols(_message, timeout=_timeout), unwraps=[])
                    return result
                except grpc.RpcError as e:
                    # Retrying unidentified grpc errors to keep clients from crashing
                    if (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details()) or\
                    (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()):
                        logging.info('Bypassed ({}: {}) error for grpc: ont.rpc.protocol.ProtocolService.list_protocols. Attempt {}.'.format(e.code(), e.details(), i))
                    else:
                        raise
                    error = e
                time.sleep(1)
            raise error

        unused_args = set(kwargs.keys())

        _message = ListProtocolsRequest()

        if 'force_reload' in kwargs:
            unused_args.remove('force_reload')
            _message.force_reload = kwargs['force_reload']

        if len(unused_args) > 0:
            raise ArgumentError("list_protocols got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        retry_count = 20
        error = None
        for i in range(retry_count):
            try:
                result = MessageWrapper(self._stub.list_protocols(_message, timeout=_timeout), unwraps=[])
                return result
            except grpc.RpcError as e:
                # Retrying unidentified grpc errors to keep clients from crashing
                if (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details()) or\
                (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()):
                    logging.info('Bypassed ({}: {}) error for grpc: ont.rpc.protocol.ProtocolService.list_protocols. Attempt {}.'.format(e.code(), e.details(), i))
                else:
                    raise
                error = e
            time.sleep(1)
        raise error

    def get_context_info(self, _message=None, _timeout=None, **kwargs):
        """
        Returns string-to-string map of the context tags

        Since 1.11

        :rtype: GetContextInfoResponse
        """
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            retry_count = 20
            error = None
            for i in range(retry_count):
                try:
                    result = MessageWrapper(self._stub.get_context_info(_message, timeout=_timeout), unwraps=[])
                    return result
                except grpc.RpcError as e:
                    # Retrying unidentified grpc errors to keep clients from crashing
                    if (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details()) or\
                    (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()):
                        logging.info('Bypassed ({}: {}) error for grpc: ont.rpc.protocol.ProtocolService.get_context_info. Attempt {}.'.format(e.code(), e.details(), i))
                    else:
                        raise
                    error = e
                time.sleep(1)
            raise error

        unused_args = set(kwargs.keys())

        _message = GetContextInfoRequest()

        if len(unused_args) > 0:
            raise ArgumentError("get_context_info got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        retry_count = 20
        error = None
        for i in range(retry_count):
            try:
                result = MessageWrapper(self._stub.get_context_info(_message, timeout=_timeout), unwraps=[])
                return result
            except grpc.RpcError as e:
                # Retrying unidentified grpc errors to keep clients from crashing
                if (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details()) or\
                (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()):
                    logging.info('Bypassed ({}: {}) error for grpc: ont.rpc.protocol.ProtocolService.get_context_info. Attempt {}.'.format(e.code(), e.details(), i))
                else:
                    raise
                error = e
            time.sleep(1)
        raise error

    def set_context_info(self, _message=None, _timeout=None, **kwargs):
        """
        Store context tags as arbitary string-to-string map

        Since 1.11

        :param context_info:
        :rtype: SetContextInfoResponse
        """
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            retry_count = 20
            error = None
            for i in range(retry_count):
                try:
                    result = MessageWrapper(self._stub.set_context_info(_message, timeout=_timeout), unwraps=[])
                    return result
                except grpc.RpcError as e:
                    # Retrying unidentified grpc errors to keep clients from crashing
                    if (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details()) or\
                    (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()):
                        logging.info('Bypassed ({}: {}) error for grpc: ont.rpc.protocol.ProtocolService.set_context_info. Attempt {}.'.format(e.code(), e.details(), i))
                    else:
                        raise
                    error = e
                time.sleep(1)
            raise error

        unused_args = set(kwargs.keys())

        _message = SetContextInfoRequest()

        if 'context_info' in kwargs:
            unused_args.remove('context_info')
            _message.context_info.update(kwargs['context_info'])

        if len(unused_args) > 0:
            raise ArgumentError("set_context_info got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        retry_count = 20
        error = None
        for i in range(retry_count):
            try:
                result = MessageWrapper(self._stub.set_context_info(_message, timeout=_timeout), unwraps=[])
                return result
            except grpc.RpcError as e:
                # Retrying unidentified grpc errors to keep clients from crashing
                if (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details()) or\
                (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()):
                    logging.info('Bypassed ({}: {}) error for grpc: ont.rpc.protocol.ProtocolService.set_context_info. Attempt {}.'.format(e.code(), e.details(), i))
                else:
                    raise
                error = e
            time.sleep(1)
        raise error

    def get_sample_id(self, _message=None, _timeout=None, **kwargs):
        """
        Sample id is a value set from the GUI that is defined by the user to identify an experiment.
        This call gets this value
        Deprecated: The sample_id is provided in the ProtocolRunUserInfo

        Since 1.11

        :rtype: GetSampleIdResponse
        """
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            retry_count = 20
            error = None
            for i in range(retry_count):
                try:
                    result = MessageWrapper(self._stub.get_sample_id(_message, timeout=_timeout), unwraps=[])
                    return result
                except grpc.RpcError as e:
                    # Retrying unidentified grpc errors to keep clients from crashing
                    if (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details()) or\
                    (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()):
                        logging.info('Bypassed ({}: {}) error for grpc: ont.rpc.protocol.ProtocolService.get_sample_id. Attempt {}.'.format(e.code(), e.details(), i))
                    else:
                        raise
                    error = e
                time.sleep(1)
            raise error

        unused_args = set(kwargs.keys())

        _message = GetSampleIdRequest()

        if len(unused_args) > 0:
            raise ArgumentError("get_sample_id got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        retry_count = 20
        error = None
        for i in range(retry_count):
            try:
                result = MessageWrapper(self._stub.get_sample_id(_message, timeout=_timeout), unwraps=[])
                return result
            except grpc.RpcError as e:
                # Retrying unidentified grpc errors to keep clients from crashing
                if (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details()) or\
                (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()):
                    logging.info('Bypassed ({}: {}) error for grpc: ont.rpc.protocol.ProtocolService.get_sample_id. Attempt {}.'.format(e.code(), e.details(), i))
                else:
                    raise
                error = e
            time.sleep(1)
        raise error

    def set_sample_id(self, _message=None, _timeout=None, **kwargs):
        """
        Sets the sample id. Refer to get_sample_id for what sample id is used for
        Deprecated: The sample_id should be set in the request when a protocol starts ( start_protocol() )

        Since 1.11

        :param sample_id:
        :rtype: SetSampleIdResponse
        """
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            retry_count = 20
            error = None
            for i in range(retry_count):
                try:
                    result = MessageWrapper(self._stub.set_sample_id(_message, timeout=_timeout), unwraps=[])
                    return result
                except grpc.RpcError as e:
                    # Retrying unidentified grpc errors to keep clients from crashing
                    if (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details()) or\
                    (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()):
                        logging.info('Bypassed ({}: {}) error for grpc: ont.rpc.protocol.ProtocolService.set_sample_id. Attempt {}.'.format(e.code(), e.details(), i))
                    else:
                        raise
                    error = e
                time.sleep(1)
            raise error

        unused_args = set(kwargs.keys())

        _message = SetSampleIdRequest()

        if 'sample_id' in kwargs:
            unused_args.remove('sample_id')
            _message.sample_id = kwargs['sample_id']

        if len(unused_args) > 0:
            raise ArgumentError("set_sample_id got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        retry_count = 20
        error = None
        for i in range(retry_count):
            try:
                result = MessageWrapper(self._stub.set_sample_id(_message, timeout=_timeout), unwraps=[])
                return result
            except grpc.RpcError as e:
                # Retrying unidentified grpc errors to keep clients from crashing
                if (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details()) or\
                (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()):
                    logging.info('Bypassed ({}: {}) error for grpc: ont.rpc.protocol.ProtocolService.set_sample_id. Attempt {}.'.format(e.code(), e.details(), i))
                else:
                    raise
                error = e
            time.sleep(1)
        raise error

    def get_protocol_purpose(self, _message=None, _timeout=None, **kwargs):
        """
        Value set by protocol scripts to define the purpose of the script. Gets this value

        Since 1.11

        :rtype: GetProtocolPurposeResponse
        """
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            retry_count = 20
            error = None
            for i in range(retry_count):
                try:
                    result = MessageWrapper(self._stub.get_protocol_purpose(_message, timeout=_timeout), unwraps=[])
                    return result
                except grpc.RpcError as e:
                    # Retrying unidentified grpc errors to keep clients from crashing
                    if (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details()) or\
                    (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()):
                        logging.info('Bypassed ({}: {}) error for grpc: ont.rpc.protocol.ProtocolService.get_protocol_purpose. Attempt {}.'.format(e.code(), e.details(), i))
                    else:
                        raise
                    error = e
                time.sleep(1)
            raise error

        unused_args = set(kwargs.keys())

        _message = GetProtocolPurposeRequest()

        if len(unused_args) > 0:
            raise ArgumentError("get_protocol_purpose got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        retry_count = 20
        error = None
        for i in range(retry_count):
            try:
                result = MessageWrapper(self._stub.get_protocol_purpose(_message, timeout=_timeout), unwraps=[])
                return result
            except grpc.RpcError as e:
                # Retrying unidentified grpc errors to keep clients from crashing
                if (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details()) or\
                (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()):
                    logging.info('Bypassed ({}: {}) error for grpc: ont.rpc.protocol.ProtocolService.get_protocol_purpose. Attempt {}.'.format(e.code(), e.details(), i))
                else:
                    raise
                error = e
            time.sleep(1)
        raise error

    def set_protocol_purpose(self, _message=None, _timeout=None, **kwargs):
        """
        Sets the protocol purpose. See also get_protocol_purpose

        Since 1.11

        :param purpose:
        :rtype: SetProtocolPurposeResponse
        """
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            retry_count = 20
            error = None
            for i in range(retry_count):
                try:
                    result = MessageWrapper(self._stub.set_protocol_purpose(_message, timeout=_timeout), unwraps=[])
                    return result
                except grpc.RpcError as e:
                    # Retrying unidentified grpc errors to keep clients from crashing
                    if (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details()) or\
                    (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()):
                        logging.info('Bypassed ({}: {}) error for grpc: ont.rpc.protocol.ProtocolService.set_protocol_purpose. Attempt {}.'.format(e.code(), e.details(), i))
                    else:
                        raise
                    error = e
                time.sleep(1)
            raise error

        unused_args = set(kwargs.keys())

        _message = SetProtocolPurposeRequest()

        if 'purpose' in kwargs:
            unused_args.remove('purpose')
            _message.purpose = kwargs['purpose']

        if len(unused_args) > 0:
            raise ArgumentError("set_protocol_purpose got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        retry_count = 20
        error = None
        for i in range(retry_count):
            try:
                result = MessageWrapper(self._stub.set_protocol_purpose(_message, timeout=_timeout), unwraps=[])
                return result
            except grpc.RpcError as e:
                # Retrying unidentified grpc errors to keep clients from crashing
                if (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details()) or\
                (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()):
                    logging.info('Bypassed ({}: {}) error for grpc: ont.rpc.protocol.ProtocolService.set_protocol_purpose. Attempt {}.'.format(e.code(), e.details(), i))
                else:
                    raise
                error = e
            time.sleep(1)
        raise error

    def add_epi2me_workflow(self, _message=None, _timeout=None, **kwargs):
        """
        Links an epi2me workflow reference to a run id.

        Since 1.15

        :param run_id: (required)
        :param epi2me_workflow: (required)
        :rtype: AddEpi2meWorkflowResponse
        """
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            retry_count = 20
            error = None
            for i in range(retry_count):
                try:
                    result = MessageWrapper(self._stub.add_epi2me_workflow(_message, timeout=_timeout), unwraps=[])
                    return result
                except grpc.RpcError as e:
                    # Retrying unidentified grpc errors to keep clients from crashing
                    if (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details()) or\
                    (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()):
                        logging.info('Bypassed ({}: {}) error for grpc: ont.rpc.protocol.ProtocolService.add_epi2me_workflow. Attempt {}.'.format(e.code(), e.details(), i))
                    else:
                        raise
                    error = e
                time.sleep(1)
            raise error

        unused_args = set(kwargs.keys())

        _message = AddEpi2meWorkflowRequest()

        if 'run_id' in kwargs:
            unused_args.remove('run_id')
            _message.run_id = kwargs['run_id']
        else:
            raise ArgumentError("add_epi2me_workflow requires a 'run_id' argument")

        if 'epi2me_workflow' in kwargs:
            unused_args.remove('epi2me_workflow')
            _message.epi2me_workflow.CopyFrom(kwargs['epi2me_workflow'])
        else:
            raise ArgumentError("add_epi2me_workflow requires a 'epi2me_workflow' argument")

        if len(unused_args) > 0:
            raise ArgumentError("add_epi2me_workflow got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        retry_count = 20
        error = None
        for i in range(retry_count):
            try:
                result = MessageWrapper(self._stub.add_epi2me_workflow(_message, timeout=_timeout), unwraps=[])
                return result
            except grpc.RpcError as e:
                # Retrying unidentified grpc errors to keep clients from crashing
                if (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details()) or\
                (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()):
                    logging.info('Bypassed ({}: {}) error for grpc: ont.rpc.protocol.ProtocolService.add_epi2me_workflow. Attempt {}.'.format(e.code(), e.details(), i))
                else:
                    raise
                error = e
            time.sleep(1)
        raise error

    def list_protocol_group_ids(self, _message=None, _timeout=None, **kwargs):
        """
        List all used protocol group ids used in any previous protocol on the box.

        Since 3.2

        :rtype: ListProtocolGroupIdsResponse
        """
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            retry_count = 20
            error = None
            for i in range(retry_count):
                try:
                    result = MessageWrapper(self._stub.list_protocol_group_ids(_message, timeout=_timeout), unwraps=[])
                    return result
                except grpc.RpcError as e:
                    # Retrying unidentified grpc errors to keep clients from crashing
                    if (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details()) or\
                    (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()):
                        logging.info('Bypassed ({}: {}) error for grpc: ont.rpc.protocol.ProtocolService.list_protocol_group_ids. Attempt {}.'.format(e.code(), e.details(), i))
                    else:
                        raise
                    error = e
                time.sleep(1)
            raise error

        unused_args = set(kwargs.keys())

        _message = ListProtocolGroupIdsRequest()

        if len(unused_args) > 0:
            raise ArgumentError("list_protocol_group_ids got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        retry_count = 20
        error = None
        for i in range(retry_count):
            try:
                result = MessageWrapper(self._stub.list_protocol_group_ids(_message, timeout=_timeout), unwraps=[])
                return result
            except grpc.RpcError as e:
                # Retrying unidentified grpc errors to keep clients from crashing
                if (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details()) or\
                (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()):
                    logging.info('Bypassed ({}: {}) error for grpc: ont.rpc.protocol.ProtocolService.list_protocol_group_ids. Attempt {}.'.format(e.code(), e.details(), i))
                else:
                    raise
                error = e
            time.sleep(1)
        raise error


